day 1.

learn segmented mode asm programming is dos environment 
this will give as an ability to move to protected mode from real mode

we can use only low part of intr service routine and fill high part with zeroes
low part can be used literally and placed in .short size storage

GDT should be aligned on 8 byte boundary
IDT should be also aligned on 8 byte

the next step is to add C startup routine which will display message on the screen
also, may be rodata section should be added to linker script to hold C constants

various objdump use cases

objdump -x (display all available header information)
objdump -x -S (with disassembly)

next steps

1. bootloader: we will use copy.sh hosted freedos, after that i'll grab the image and reformat it using floppy utility and make filesystem on it
after making filesystem i'll copy binary image and check fat contents. if it's simple enough i'll try to write the simplest possible loader 
which use 512 byte buffer to load image on 32k boundary

2. simplify system code, drop unnecessary strlen calls and don't use line increments. just keep current screen buffer counter

floppy disk image file can be created using the following command

# mkdosfs -n TCOS -C tcos.img -S 512 720

after switching to protected mode it can be necessary to use floppy disk controller
extensive documentation about floppy disk controller programming can be found by keyword 3F0h floppy disk controller

not bad resource is the http://www.isdaman.com/alsos/hardware/fdc/floppy.htm

also book Microprocessors, PC Hardware and interfacing contains useful information abount FDC/IDE programming

we should check offsets in generated binary and place far jump at the and of data section and then jump to it after init code completion
this also means that we need to patch mbr start jump with fixed offset

in ISRs assigned to interrupts with error code, handler should remove error from stack before returning

programming 8259A interrupt controller

4 ICWs (initialization command words)

programming interrupt controller w/o AEOI (automatic end of interrupt) at first

ICW1 

ICW2 - interrupt vectors assignment (should be set starting from 32)

ICW3 - for cascaded mode operation

ICW4 - for interrupt controller fine tuning (AEOI for example)

I/O ports for PIC (programmable interrupt controller) interfacing

20 - for master controller
A0 - for slave controller

configuring master controller

icw1 - 000010001 ( 0x11) # edge triggered, cascade mode, ICW4 see page 423 of IBM PC and Compatible Computers
icw1 will be written to port 0x20
other initialization commands will be written to port 0x21

icw2 - 0x20 # 0-7 interrupts will be assigned to handlers starting from 32

performing I/O using GAS: outb %al, $0x20

configuring slave controller

task switching considerations

1. system task will be initialized using the following steps

TSS segment descriptor will be placed to GDT and loaded using LTR
after that we will perform some actions with flags register (nested task set) and perform iret to switch to system task
the previous step is not strictly required cause we can perform jump with task switch directly to user code

2. for user tasks we will use another TSS segment selector in GDT and perform switch to it

segment descriptor busy flag is used during task switches

current tasks architecture will be designed the following way:

system task after initialization will far jmp to user task (unix init process analog)

busy flag for system task will be cleared, and task link won't be saved

switch to system task will be performed using INT to task gate configured to system task
we'll return to system task just after jmp to user instruction. here we'll perform system call dispatch
perform sys call and return to user code using iret

timer interrupt will be linked to scheduler code and can perform task switch

we should try to perform task switch w/o ldt selector 
in case of failure we should add LDT descriptor to GDT and load this descriptor 
using lldt command by passing it LDT selector in GTD

example:

movw 0x8, %ax
lldt %ax

this selector should be used in all TSS segments

we won't use ldt so we'll fill LDT segment selector with zeroes
page directory base register is also filled with zeroes

stack top, task segments base addresses and it's limits should be defined in linker script and reference from init.s
