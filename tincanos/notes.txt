day 1.

learn segmented mode asm programming is dos environment 
this will give as an ability to move to protected mode from real mode

we can use only low part of intr service routine and fill high part with zeroes
low part can be used literally and placed in .short size storage

GDT should be aligned on 8 byte boundary
IDT should be also aligned on 8 byte

the next step is to add C startup routine which will display message on the screen
also, may be rodata section should be added to linker script to hold C constants

various objdump use cases

objdump -x (display all available header information)
objdump -x -S (with disassembly)

next steps

1. bootloader: we will use copy.sh hosted freedos, after that i'll grab the image and reformat it using floppy utility and make filesystem on it
after making filesystem i'll copy binary image and check fat contents. if it's simple enough i'll try to write the simplest possible loader 
which use 512 byte buffer to load image on 32k boundary

2. simplify system code, drop unnecessary strlen calls and don't use line increments. just keep current screen buffer counter

floppy disk image file can be created using the following command

# mkdosfs -n TCOS -C tcos.img -S 512 720

after switching to protected mode it can be necessary to use floppy disk controller
extensive documentation about floppy disk controller programming can be found by keyword 3F0h floppy disk controller

not bad resource is the http://www.isdaman.com/alsos/hardware/fdc/floppy.htm

also book Microprocessors, PC Hardware and interfacing contains useful information abount FDC/IDE programming

we should check offsets in generated binary and place far jump at the and of data section and then jump to it after init code completion
this also means that we need to patch mbr start jump with fixed offset

in ISRs assigned to interrupts with error code, handler should remove error from stack before returning

programming 8259A interrupt controller

4 ICWs (initialization command words)

programming interrupt controller w/o AEOI (automatic end of interrupt) at first

ICW1 

ICW2 - interrupt vectors assignment (should be set starting from 32)

ICW3 - for cascaded mode operation

ICW4 - for interrupt controller fine tuning (AEOI for example)

I/O ports for PIC (programmable interrupt controller) interfacing

20 - for master controller
A0 - for slave controller

configuring master controller

icw1 - 000010001 ( 0x11) # edge triggered, cascade mode, ICW4 see page 423 of IBM PC and Compatible Computers
icw1 will be written to port 0x20
other initialization commands will be written to port 0x21

icw2 - 0x20 # 0-7 interrupts will be assigned to handlers starting from 32

performing I/O using GAS: outb %al, $0x20

configuring slave controller

task switching considerations

1. system task will be initialized using the following steps

TSS segment descriptor will be placed to GDT and loaded using LTR

2. for user tasks we will use another TSS segment selector in GDT and perform switch to it

segment descriptor busy flag is used during task switches

current tasks architecture will be designed the following way:

switch to system task will be performed using INT to task gate configured to system task
we'll return to system task just after jmp to user instruction. here we'll perform system call dispatch
perform sys call and return to user code using iret

timer interrupt will be linked to scheduler code and can perform task switch

task management plan

1. Switch to user task using 2 task segments: activate system task first, then jmp to user task
this step is needed to check various flags which will be set in task segment

after that interrupt handling should work as expected (by performing stack switch on handling, may be data segments switch required in interrupt handler)
the only drawback is that syscall mechanism is not clear in this case

if perform syscall by passing through task gate than interrupt handling will be performed with PL = 0 but w/o task context but syscall with PL = 0 but with task context

2. to solve the above problem we'll use one task segment for user space tasks and switch to it using IRET technique
switch to system space will be performed using IRET to interrupt gate with DPL = 3 but handler located in system code segment

DMA programming notes

default DMA channels assignment scheme:

0 - DRAM refresh in PC/XT times (unused anymore)
1 - not assigned, can be used for any activities
2 - floppy disk controller
3 - HDD controller

Main aspects of DMA programming (I/O ports : DMA registers association can be found in any books about DMA programming i.e. page 460 of IBM PC and Compatible)

Command register (I/O port 0x8 for DMA #1): controlling the operation of DMA controller
Status register (the same I/O port as control but for reading only): active channel request bist will be set here
Mode register 
Single mask register: can be used for masking specific DMA channel
All mask register: can be used for bulk masking of DMA channels

on top of the control/mode registers there are memory address/count registers for each DMA channel
by using them we can specify memory block address and it's size for DMA operation

default floppy disk interrupt assignment is IRQ6
and DMA channel 1 or 2 (will be checked during programming)

Practice:
1. DMA controller should be enabled before use

movb $0x4, %ax
outb %ax, $0x8

also, current DMA controller state fcan be read right from the command register

floppy disk controller programming notes
1. all command to controler are passed through data register (which size is 16 bits)
16-bit I/O instructions can use immediate ports but should use 16-bit register and by aligned by word boundary

data register size is not 16-bits but 16 bytes. controller commands should be passed byte by byte

all commands execution are splitted into 3 phases: issue command, wait for result, read command completion status

running comiled boot image using qemu and consuming 1m of memory only

qemu-system-i386 -m 1 -display curses -fda tincanos.img -no-fd-bootchk -boot order=a
